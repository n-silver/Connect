<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Connect</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no">

  <!-- Montserrat font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg:#fafafa; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb; --focus:#0b57d0;
      --tile-font: 14px;     /* default size */
      --tile-font-min: 5px; /* minimum size when auto-fitting */
      --tile-h: 70px;        /* tile height; keep 4 columns across devices */
    }

    html, body { height:100%; }
    *, *::before, *::after { -webkit-text-fill-color: currentColor; box-sizing:border-box; }
    body { margin:0; font-family:'Montserrat', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg); }

    .wrap { max-width:1200px; margin:0 auto; padding:16px; }
    h1 { margin:15px 0 30px; fontsize: var(--heading-size); font-weight:700; letter-spacing:.2px; }
    .sub { color:var(--muted); font-size:12px; margin:0 0 12px; }

    /* Toolbar */
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px; }
    select, button {
      border:1px solid var(--border); background:var(--card); border-radius:10px;
      padding:8px 10px; font-size:14px; cursor:pointer; color:var(--fg); -webkit-appearance:none; appearance:none;
    }
    button { font-weight:600; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    a { color: inherit; text-decoration: none; }
    .sr-only { position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

.topbar {
  display: flex;
  align-items: center;           /* vertically center select against the H1 */
  justify-content: space-between;/* push to opposite sides */
  gap: 12px;
  margin-bottom: 12px;
}

/* Optional: tune heading spacing/size */
.topbar .title { 
  margin: 15px 0 30px; 
  font-size: 40px;               /* adjust to taste */
  font-weight: 700; 
  letter-spacing: .2px; 
}

/* Keep the select tidy on one line */
.topbar .date-slot select {
  min-width: 100px;              /* tweak if you want narrower/wider */
  white-space: nowrap;
}

/* On very small screens, keep them on one line if possible; otherwise let it wrap */
@media (max-width: 360px) {
  .topbar .date-slot select { min-width: 160px; }
}

    
    /* Grid & tiles */

.check-wrap {
  display: flex;
  justify-content: center;
  margin-top: 12px;
}

.check-btn {
  border: 1px solid var(--border);
  background: var(--card);
  color: var(--fg);
  border-radius: 10px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
  transition: background .15s ease, color .15s ease, border-color .15s ease, opacity .15s ease;
}

/* turns black with white text when 4 tiles selected */
.check-btn.ready {
  background: #111;
  border-color: #111;
  color: #fff;
}



.actions {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-top: 12px;
}

/* Optional: keep buttons consistent; you likely already have base styles for button */
.actions .help-btn,
.actions .check-btn {
  border: 1px solid var(--border);
  background: var(--card);
  color: var(--fg);
  border-radius: 10px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
}

/* You already have the “ready” style for Check; keep it */
.check-btn.ready {
  background: #111;
  border-color: #111;
  color: #fff;
}


    
    .grid { display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; max-width:680px; margin:0 auto; }
    .tile {
      height:var(--tile-h); border:1px solid var(--border); border-radius:14px; background:var(--card);
      font-weight:700; font-size:var(--tile-font); letter-spacing:.2px; padding:0 10px;
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
      transition: background .15s ease, border-color .15s ease, transform .15s ease;
      user-select:none; overflow:hidden; white-space:nowrap; color: var(--fg);
    }
    .tile.solved { opacity:.95; }
    .tile:focus-visible { outline:2px solid var(--focus); outline-offset:2px; }

    .status { margin:14px 0; font-size:14px; color:var(--muted); min-height:1.5em; text-align:center; }
    .footer { text-align:center; color:var(--muted); font-size:12px; margin-top:16px; }
    code { background:#eee; padding:1px 4px; border-radius:4px; }

  

 /* Pastel palette for solved groups */
    .tile.solved.solved-group.p-blue   { background:#e8f2ff !important; border-color:#cfe5ff !important; color:#0f253a !important; }
    .tile.solved.solved-group.p-yellow { background:#fff7cc !important; border-color:#ffe78a !important; color:#3a3200 !important; }
    .tile.solved.solved-group.p-pink   { background:#ffe0ea !important; border-color:#ffc3d6 !important; color:#3a0e20 !important; }
    .tile.solved.solved-group.p-green  { background:#e6f7e6 !important; border-color:#c9ebc9 !important; color:#0f2a0f !important; }


/* Animated pastel flow ring for ANY selected tile */
:root { --sel-ring: 3px; } /* ring thickness; 1px matches your normal border */

.tile { --sel-fill:#fff; } /* inner fill default (white) */

.tile.sel {
  /* Make the gradient live in the border so it fits perfectly (no gaps/clipping) */
  border: var(--sel-ring) solid transparent;
  border-radius: 14px; /* match your .tile radius exactly */
  background:
    /* inner layer: the tile fill (changes on hover) */
    linear-gradient(var(--sel-fill), var(--sel-fill)) padding-box,
    /* outer layer: animated pastel flow ring */
    linear-gradient(90deg,
      #FFE78A 0%,
      #C9EBC9 25%,
      #CFE5FF 50%,
      #FFC3D6 75%,
      #FFE78A 100%
    ) border-box;
  background-size: 100% 100%, 300% 100%;
  background-position: 0 0, 0% 50%;
  animation: selPastelFlow 6s linear infinite;
  will-change: background-position;
  box-shadow: 0 1px 2px rgba(0,0,0,.05); /* keep the subtle shadow */
}



@keyframes selPastelFlow {
  0%   { background-position: 0 0,   0% 50%; }
  100% { background-position: 0 0, 300% 50%; }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  .tile.sel { animation: none; }
}









    
    /* Solved group container spanning full width */
    .solved-group { grid-column:1 / -1; padding:12px; border-radius:14px; text-align:center; display:flex; flex-direction:column; gap:4px; }
    .solved-title { font-weight:700; font-size:14px; letter-spacing:.2px; margin:0; text-align:center; }
    .solved-words-line { font-weight:500; font-size:14px; opacity:.95; }

    /* Compact solved panel chips (optional) */
    .solved-list { display:none; }
    .solved { border:1px solid var(--border); border-radius:12px; padding:8px 10px; font-weight:600; display:flex; flex-wrap:wrap; gap:8px; align-items:center; background:var(--card); }

    /* Keep 4 columns even on small screens; tiles will shrink and auto-fit text */
    @media (max-width: 360px) {
      :root { --tile-font: 13px; --tile-h: 78px; --heading-size: clamp(100px, 6vw, 100px);}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Top bar: title left, date select right -->
<div class="topbar">
  <h1 class="title">connect</h1>
  <div class="date-slot">
    <label for="puzzle-select" class="sr-only">Choose puzzle</label>
    <select id="puzzle-select" aria-label="Choose puzzle"></select>
  </div>
</div>


    <div id="solved" class="solved-list" aria-live="polite"></div>
    <div id="grid" class="grid" role="grid" aria-label="Connections grid of 16 tiles"></div>
    
   <!-- Bottom actions: Help (left) + Check (right) -->
<div class="actions">
  <button id="btn-help" class="help-btn" title="Reveal two tiles">Help</button>
  <button id="btn-check" class="check-btn" title="Check selected tiles" aria-disabled="true">Check</button>
</div>


    <div class="footer">
    </div>
  </div>

  <!-- No embedded JSON. The app fetches /puzzles/manifest.json and /puzzles/<date>.json -->

  <script>
  (function () {
    // ===== Helpers =====
    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
    const shuffle = arr => { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; };

    const PASTELS = ['p-blue','p-yellow','p-pink','p-green'];

    // State
    let manifest = [];            // ['2025-09-13', '2025-09-12', ...] newest first
    let puzzleCache = new Map();  // date -> { date, categories }
    let currentDate = null;
    let selected = [];
    let solvedGroups = [];
    let layout = [];
    // Two-step Help state: when set, we have a staged group with 2 hinted tiles
    let stagedHelp = null; // { group, hinted: Set<string>, color: string }


    // Elements
    const sel = $('#puzzle-select');
    const grid = $('#grid');
    const solvedList = $('#solved');
    const btnCheck = $('#btn-check');
    const btnHelp = $('#btn-help');
    const msg = $('#msg');

    // Font-fit helpers
    const BASE_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font')) || 14;
    const MIN_SIZE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font-min')) || 10;
    function fits(el){ return el.scrollWidth <= el.clientWidth && el.scrollHeight <= el.clientHeight; }
    function fitText(el){
      el.style.fontSize = BASE_SIZE + 'px';
      if (fits(el)) return;
      let size = BASE_SIZE;
      while (size > MIN_SIZE) {
        size -= 1;
        el.style.fontSize = size + 'px';
        if (fits(el)) break;
      }
    }
    function fitAllTiles(){ [...$$(".tile"), ...$$("[data-fit]")].forEach(fitText); }
    const ro = new ResizeObserver(() => fitAllTiles());

    // ===== Loading =====
    async function fetchJSON(url){
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
      return await res.json();
    }

    async function loadManifest() {
      try {
        manifest = await fetchJSON('/puzzles/manifest.json');
        if (!Array.isArray(manifest) || !manifest.length) throw new Error('empty manifest');
      } catch {
        // fallback to latest.json only
        try {
          const latest = await fetchJSON('/puzzles/latest.json');
          if (latest?.date) { manifest = [latest.date]; puzzleCache.set(latest.date, latest); }
        } catch (e) {
          console.error('Failed to load any puzzle data', e);
          manifest = [];
        }
      }
    }

    async function loadPuzzle(date) {
      if (puzzleCache.has(date)) return puzzleCache.get(date);
      try {
        const data = await fetchJSON(`/puzzles/${date}.json`);
        puzzleCache.set(date, data);
        return data;
      } catch {
        // fallback: latest
        const data = await fetchJSON(`/puzzles/latest.json`);
        puzzleCache.set(data.date, data);
        return data;
      }
    }

    function populateSelect() {
      sel.innerHTML = '';
      manifest.forEach((d) => {
        const opt = document.createElement('option');
        opt.value = d;
        opt.textContent = d;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', async () => {
        currentDate = sel.value;
        await startPuzzle(); // reload for selected date
      });
    }

    // ===== Layout helpers =====
    function wordsOfSolved() { return solvedGroups.flatMap(g => g.words); }
    function isSolvedWord(w) { return solvedGroups.some(g => g.words.includes(w)); }

    function buildInitialLayout(p) {
      const words = p.categories.flatMap(c => c.words);
      shuffle(words);
      layout = words;
    }

    function rebuildLayoutSolvedFirst() {
      const top = [];
      const seen = new Set();
      for (const g of solvedGroups) for (const w of g.words) if (!seen.has(w)) { top.push(w); seen.add(w); }
      const rest = layout.filter(w => !seen.has(w));
      layout = [...top, ...rest];
    }

    function colorClassForWord(w) {
      for (let i = 0; i < solvedGroups.length; i++) {
        if (solvedGroups[i].words.includes(w)) return PASTELS[i] || PASTELS[PASTELS.length - 1];
      }
      return '';
    }

    function updateCheckUI() {
  const ready = selected.length === 4;
  btnCheck.classList.toggle('ready', ready);
  btnCheck.setAttribute('aria-disabled', ready ? 'false' : 'true');
}


    // ===== Render =====
    function renderGrid() {
      grid.innerHTML = '';

      // solved groups (full-width)
      solvedGroups.forEach((g, idx) => {
        const cont = document.createElement('div');
        cont.className = `tile solved solved-group ${PASTELS[idx] || PASTELS[PASTELS.length - 1]}`;
        cont.style.gridColumn = '1 / -1';

        const title = document.createElement('div');
        title.className = 'solved-title';
        title.textContent = g.title;

        const wordsLine = document.createElement('div');
        wordsLine.className = 'solved-words-line';
        wordsLine.textContent = g.words.join(', ');

        cont.appendChild(title);
        cont.appendChild(wordsLine);
        grid.appendChild(cont);
      });

      // remaining tiles
      for (const w of layout) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tile';
        btn.textContent = w;
        // HINT: color the hinted tiles
        if (stagedHelp && stagedHelp.hinted && stagedHelp.hinted.has(w)) {
          btn.classList.add('hint', stagedHelp.color);
          }
        btn.addEventListener('click', () => toggleWord(btn, w));
        grid.appendChild(btn);
        ro.observe(btn);
      }
      fitAllTiles();
    }

    function renderSolvedPanel() {
      solvedList.innerHTML = '';
      solvedGroups.forEach((g, idx) => {
        const div = document.createElement('div');
        div.className = `solved ${PASTELS[idx] || PASTELS[PASTELS.length - 1]}`;
        div.innerHTML = `<span>${g.title}</span><span style="opacity:.6">•</span><span>${g.words.join(', ')}</span>`;
        solvedList.appendChild(div);
      });
    }

    // ===== Game flow =====
    async function startPuzzle() {
      selected = [];
      solvedGroups = [];
      stagedHelp = null;
      updateCheckUI();

      const p = await loadPuzzle(currentDate);
      buildInitialLayout(p);
      renderGrid();
    }

    function toggleWord(el, word) {
  if (isSolvedWord(word)) return;

  const i = selected.indexOf(word);

  if (i >= 0) {
    // Deselect allowed (even for hinted tiles)
    selected.splice(i, 1);
    el.classList.remove('sel');
  } else {
    // Select
    if (selected.length === 4) {
      clearSelectionClasses();
      selected = [word];
      el.classList.add('sel');
    } else {
      selected.push(word);
      el.classList.add('sel');
    }
  }

  if (typeof updateCheckUI === 'function') updateCheckUI();
}


    function clearSelectionClasses() {
      $$('.tile.sel').forEach(n => n.classList.remove('sel'));
    }

    function checkSelection() {
      if (selected.length !== 4) return;
      loadPuzzle(currentDate).then(p => {
        const pick = new Set(selected);
        const match = p.categories.find(c => c.words.every(w => pick.has(w)));

        if (match && !solvedGroups.some(g => g.title === match.title)) {
          revealGroup(match);
        } else {
          clearSelectionClasses();
          selected = [];
          updateCheckUI();

        }
      });
    }

    function revealGroup(group) {
        if (stagedHelp && stagedHelp.group && stagedHelp.group.title === group.title) {
    stagedHelp = null;
  }
      solvedGroups.push(group);
      const gset = new Set(group.words);
      layout = layout.filter(w => !gset.has(w));
      selected = [];
      updateCheckUI();
      renderGrid();
    }

    function helpSolveOne(randomize=true) {
      loadPuzzle(currentDate).then(p => {
        const unsolved = p.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
        if (!unsolved.length) return;
        const group = randomize ? unsolved[Math.floor(Math.random()*unsolved.length)] : unsolved[0];
        revealGroup(group);
      });
    }



    // Wire up controls
    btnCheck.addEventListener('click', checkSelection);
btnHelp.addEventListener('click', handleHelp);

function handleHelp() {
  // Load the current puzzle (for the /puzzles loader)
  loadPuzzle(currentDate).then(p => {
    // If we already staged a hint, finish that group on second press
    if (stagedHelp && stagedHelp.group) {
      // Reveal/solve that whole group now
      revealGroup(stagedHelp.group);
      return;
    }

    // Otherwise, stage a new random unsolved group and hint 2 tiles
    const unsolved = p.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
    if (!unsolved.length) return;

    // Pick a random group
    const group = unsolved[Math.floor(Math.random() * unsolved.length)];

    // Pick 2 of its words at random
    const words = [...group.words];
    for (let i = words.length - 1; i > 0; i--) { // shuffle
      const j = Math.floor(Math.random() * (i + 1));
      [words[i], words[j]] = [words[j], words[i]];
    }
    const two = words.slice(0, 2);

    // Assign it the *next* pastel (same as it will be when solved)
    const color = PASTELS[Math.min(solvedGroups.length, PASTELS.length - 1)] || PASTELS[0];

    // Stage hint state
    stagedHelp = { group, hinted: new Set(two), color };

    // Move the two hinted tiles to the top of the unsolved layout (first row)
    // 1) Remove them from wherever they are
    const rest = layout.filter(w => !stagedHelp.hinted.has(w));
    // 2) Put them at the front
    layout = [...two, ...rest];

    // Re-render to show colored, pinned tiles under solved rows
    renderGrid();
  });
}

    // Boot
    (async function init(){
      await loadManifest();
      if (!manifest.length) return;
      populateSelect();
      currentDate = manifest[0];
      sel.value = currentDate;
      await startPuzzle();
    })();
  })();
  </script>
</body>
</html>













