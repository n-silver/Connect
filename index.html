<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Connect</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      /* Base UI */
      --bg:#fafafa; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb; --focus:#0b57d0;
      --tile-font:14px; --tile-font-min:10px; --tile-h:70px;

      /* Radius (one knob to change roundness everywhere) */
      --radius:6px;
      --radius-btn:var(--radius);
      --radius-input:var(--radius);
      --radius-tile:var(--radius);
      --radius-solved:var(--radius);

      /* Pastel palette (borders & solved backgrounds) */
      --pastel-blue-bg:#e7f9ff;   --pastel-blue-border:#b8ecff;   --pastel-blue-fg:#0e2433;  /* brighter aqua-ish blue */
      --pastel-yellow-bg:#fff7cc; --pastel-yellow-border:#ffe78a; --pastel-yellow-fg:#3a3200;
      --pastel-pink-bg:#f4e6ff;   --pastel-pink-border:#dac6ff;   --pastel-pink-fg:#291d3a;  /* light lavender */
      --pastel-green-bg:#e6f7e6;  --pastel-green-border:#c9ebc9;  --pastel-green-fg:#0f2a0f;

      /* Animated selection / hint border uses these */
      --ring-yellow: var(--pastel-yellow-border);
      --ring-green:  var(--pastel-green-border);
      --ring-blue:   var(--pastel-blue-border);
      --ring-pink:   var(--pastel-pink-border);

      /* Buttons */
      --btn-ready-fg:#111; /* dark text on pastel fills */

      /* Animated borders thickness */
      --sel-ring:2px;  /* selected */
      --hint-ring:2px; /* hinted (must match overlay stroke) */
    }

    html,body{height:100%}
    *,*::before,*::after{box-sizing:border-box; -webkit-text-fill-color:currentColor}
    body{margin:0; font-family:'Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--fg)}
    .wrap{max-width:1200px; margin:0 auto; padding:16px}

    /* Topbar */
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding-bottom:8px; margin-bottom:16px; position:relative;
    }
    .topbar::after{
      content:""; position:absolute; left:50%; transform:translateX(-50%);
      bottom:-0.5px; width:100vw; height:1px; background:var(--border);
    }
    .title{ margin:10px 0; font-size:32px; font-weight:700; letter-spacing:.2px; text-transform:lowercase }
    .date-slot select{
      min-width:140px; border:1px solid var(--border); background:var(--card); color:var(--fg);
      border-radius:var(--radius-input); padding:8px 10px; font-size:14px; cursor:pointer; appearance:none;
    }

    /* Actions */
    .actions{ display:flex; justify-content:center; align-items:center; gap:8px; margin-top:12px }
    button{
      border:1px solid var(--border); background:var(--card); color:var(--fg);
      border-radius:var(--radius-btn); padding:10px 16px; font-size:14px; font-weight:700; cursor:pointer;
    }
    .check-btn.ready{
      border:1px solid var(--border);
      color: var(--btn-ready-fg);
      background: linear-gradient(120deg,
        var(--ring-yellow) 0%,
        var(--ring-green)  25%,
        var(--ring-blue)   50%,
        var(--ring-pink)   75%,
        var(--ring-yellow) 100%
      );
      background-size: 320% 320%;
      animation: btnFlow 16s ease-in-out infinite;
    }
    @keyframes btnFlow{ 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }

    /* Grid */
    .grid{ display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; max-width:1200px; margin:0 auto }
    .tile{
      height:var(--tile-h); border:1px solid var(--border); border-radius:var(--radius-tile); background:var(--card);
      font-weight:700; font-size:var(--tile-font); letter-spacing:.2px; padding:0 10px;
      display:flex; align-items:center; justify-content:center; white-space:nowrap; overflow:hidden;
      box-shadow:0 1px 2px rgba(0,0,0,.05); transition:background .15s ease,border-color .15s ease,transform .15s ease;
      color:var(--fg); user-select:none;
    }
    .tile:focus-visible{ outline:2px solid var(--focus); outline-offset:2px }

    /* --- Animated flowing GRADIENT BORDER (Option A) for selected AND hinted tiles --- */
    .tile.sel,
    .tile.hint{
      border: var(--sel-ring) solid transparent;  /* use --hint-ring for .hint; we equalize below */
      border-radius: var(--radius-tile);
      background:
        linear-gradient(var(--card), var(--card)) padding-box,
        linear-gradient(120deg,
          var(--ring-yellow) 0%,
          var(--ring-green)  25%,
          var(--ring-blue)   50%,
          var(--ring-pink)   75%,
          var(--ring-yellow) 100%
        ) border-box;
      background-size: 100% 100%, 320% 320%;
      background-position: 0 0, 0% 50%;
      animation: tileBorderFlow 16s ease-in-out infinite;
    }
    /* ensure hinted border thickness matches overlay stroke */
    .tile.hint{ border-width: var(--hint-ring); }
    @keyframes tileBorderFlow{ 0%{background-position:0 0, 0% 50%} 50%{background-position:0 0, 100% 50%} 100%{background-position:0 0, 0% 50%} }

    /* Solved group (full-width) */
    .solved-group{
      grid-column:1 / -1; padding:12px; border-radius:var(--radius-solved);
      text-align:center; display:flex; flex-direction:column; gap:4px
    }
    .solved-title{ font-weight:700; font-size:14px; letter-spacing:.2px; margin:0 }
    .solved-words-line{ font-weight:500; font-size:14px; opacity:.95 }

    /* Pastel fills for solved groups */
    .tile.solved.solved-group.p-blue   { background:var(--pastel-blue-bg)!important;   border-color:var(--pastel-blue-border)!important;   color:var(--pastel-blue-fg)!important }
    .tile.solved.solved-group.p-yellow { background:var(--pastel-yellow-bg)!important; border-color:var(--pastel-yellow-border)!important; color:var(--pastel-yellow-fg)!important }
    .tile.solved.solved-group.p-pink   { background:var(--pastel-pink-bg)!important;   border-color:var(--pastel-pink-border)!important;   color:var(--pastel-pink-fg)!important }
    .tile.solved.solved-group.p-green  { background:var(--pastel-green-bg)!important;  border-color:var(--pastel-green-border)!important;  color:var(--pastel-green-fg)!important }

    .solved-list{ display:none }
    .sr-only{ position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }

    @media (max-width:360px){
      :root{ --tile-font:13px; --tile-h:78px }
      .date-slot select{ min-width:160px }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 class="title">connect</h1>
      <div class="date-slot">
        <label for="puzzle-select" class="sr-only">Choose puzzle</label>
        <select id="puzzle-select" aria-label="Choose puzzle"></select>
      </div>
    </div>

    <div id="grid" class="grid" role="grid" aria-label="Connections grid of 16 tiles"></div>

    <div class="actions">
      <button id="btn-help"  class="help-btn"  title="Reveal two tiles">Help</button>
      <button id="btn-check" class="check-btn" title="Check selected tiles" aria-disabled="true">Check</button>
    </div>
  </div>

  <script>
  (function(){
    /* ---------- Helpers ---------- */
    const $  = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
    const shuffle = a => { for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a };

    /* ---------- Elements ---------- */
    let sel, grid, btnCheck, btnHelp;

    /* ---------- State ---------- */
    let manifest = [];
    const cache = new Map(); // date -> puzzle
    let currentDate = null;
    let currentPuzzle = null;
    let selected = [];
    let solvedGroups = [];
    let layout = [];
    let stagedHelp = null; // { group, hinted:Set<string> }

    /* ---------- Fit text ---------- */
    const BASE_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font')) || 14;
    const MIN_SIZE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font-min')) || 10;
    const fits = el => el.scrollWidth <= el.clientWidth && el.scrollHeight <= el.clientHeight;
    function fitText(el){
      el.style.fontSize = BASE_SIZE + 'px';
      if (fits(el)) return;
      let s = BASE_SIZE;
      while (s > MIN_SIZE) { s--; el.style.fontSize = s + 'px'; if (fits(el)) break; }
    }
    function fitAll(){ [...$$('.tile')].forEach(fitText); }

    /* ---------- Data loading ---------- */
    async function fetchJSON(cands){
      const list = Array.isArray(cands)?cands:[cands];
      for (const url of list){
        try{
          const res = await fetch(url, { cache:'no-store' });
          if (!res.ok) throw new Error();
          return await res.json();
        }catch{}
      }
      throw new Error('fetch failed: '+list.join(', '));
    }
    function todayUK(){
      const p = new Intl.DateTimeFormat('en-CA',{timeZone:'Europe/London',year:'numeric',month:'2-digit',day:'2-digit'}).formatToParts(new Date());
      const y=p.find(x=>x.type==='year').value, m=p.find(x=>x.type==='month').value, d=p.find(x=>x.type==='day').value;
      return `${y}-${m}-${d}`;
    }
    const PREVIEW = new URLSearchParams(location.search).has('preview');

    async function loadEligibleDates(){
      const all = await fetchJSON(['puzzles/manifest.json','/puzzles/manifest.json']); // newest-first
      if (PREVIEW) return all;
      const cutoff = todayUK();
      const elig = all.filter(d => d <= cutoff);
      return elig.length ? elig : all;
    }
    async function getPuzzle(dateISO){
      if (cache.has(dateISO)) return cache.get(dateISO);
      const data = await fetchJSON([`puzzles/${dateISO}.json`,`/puzzles/${dateISO}.json`]);
      cache.set(dateISO, data); return data;
    }

    /* ---------- UI helpers ---------- */
    function setDates(dates){
      sel.innerHTML = '';
      for (const d of dates){
        const o = document.createElement('option');
        o.value = d; o.textContent = d;
        sel.appendChild(o);
      }
    }
    function updateCheckUI(){
      const ready = selected.length === 4;
      btnCheck.classList.toggle('ready', ready);
      btnCheck.setAttribute('aria-disabled', ready ? 'false' : 'true');
    }

    /* ---------- Hint SVG overlay (white tracer arc) ---------- */
    function addHintOverlay(btn){
      if (btn.querySelector('.hint-overlay')) return; // already present

      const rect = btn.getBoundingClientRect();
      const brPx = parseFloat(getComputedStyle(btn).borderRadius) || 0;
      const minSide = Math.max(1, Math.min(rect.width, rect.height));
      // Map CSS px radius to the normalized 100x100 viewBox space (0..50)
      const rxUnits = Math.min(45, (brPx / minSide) * 50);

      // Normalized geometry for the overlay rect (1..99) to avoid clipping end caps
      const W = 100, H = 100, inset = 1;
      const w = W - inset*2, h = H - inset*2, r = Math.min(rxUnits, w/2, h/2);

      // Perimeter of rounded rect to compute where the top middle lies along the path
      const topEdge = w - 2*r;
      const perim = 2*(w - 2*r + h - 2*r) + 2*Math.PI*r;
      const topMiddleFromTopLeft = topEdge/2; // distance from path's start (top-left edge start) to top-middle
      const startPct = Math.max(0, Math.min(100, (topMiddleFromTopLeft / perim) * 100));

      // Build SVG overlay
      const svgNS = 'http://www.w3.org/2000/svg';
      const wrap = document.createElement('div');
      wrap.className = 'hint-overlay';
      wrap.style.position = 'absolute';
      wrap.style.inset = '0';
      wrap.style.pointerEvents = 'none';
      wrap.style.zIndex = '2';
      wrap.style.borderRadius = getComputedStyle(btn).borderRadius;

      const svg  = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', '0 0 100 100');
      svg.setAttribute('preserveAspectRatio', 'none');
      svg.style.width = '100%';
      svg.style.height = '100%';

      const rr = document.createElementNS(svgNS, 'rect');
      rr.setAttribute('x', String(inset));
      rr.setAttribute('y', String(inset));
      rr.setAttribute('width',  String(w));
      rr.setAttribute('height', String(h));
      rr.setAttribute('rx', r.toFixed(2));
      rr.setAttribute('ry', r.toFixed(2));
      rr.setAttribute('fill', 'none');
      rr.setAttribute('stroke', 'rgba(255,255,255,0.98)');
      rr.setAttribute('stroke-linecap', 'round');
      rr.setAttribute('vector-effect', 'non-scaling-stroke');
      rr.setAttribute('pathLength', '100'); // normalize to 100 units length

      // Stroke width = same as hint border thickness
      const hintRing = getComputedStyle(document.documentElement).getPropertyValue('--hint-ring').trim() || '2px';
      rr.style.strokeWidth = hintRing;

      // Start the dash at the top-middle: offset is negative of that position
      rr.style.strokeDasharray = '0 100';
      rr.style.strokeDashoffset = `-${startPct.toFixed(2)}`;

      // Animate dash (CSS below applies to .ring class)
      rr.setAttribute('class', 'ring');

      svg.appendChild(rr);
      wrap.appendChild(svg);
      btn.appendChild(wrap);
    }

    /* ---------- Render ---------- */
    function renderGrid(){
      grid.innerHTML = '';

      // Solved groups (full-width)
      solvedGroups.forEach((g, idx) => {
        const wrap = document.createElement('div');
        wrap.className = `tile solved solved-group p-${['blue','yellow','pink','green'][idx] || 'yellow'}`;
        wrap.style.gridColumn = '1 / -1';

        const t = document.createElement('div'); t.className='solved-title';      t.textContent = g.title;
        const w = document.createElement('div'); w.className='solved-words-line'; w.textContent = g.words.join(', ');
        wrap.appendChild(t); wrap.appendChild(w); grid.appendChild(wrap);
      });

      // Remaining tiles
      for (const w of layout){
        const btn = document.createElement('button');
        btn.type = 'button'; btn.className = 'tile'; btn.textContent = w;

        // Hinted tiles: gradient border + white tracer overlay
        if (stagedHelp && stagedHelp.hinted && stagedHelp.hinted.has(w)){
          btn.classList.add('hint');
          addHintOverlay(btn);
        }

        btn.addEventListener('click', () => toggleWord(btn, w));
        grid.appendChild(btn);
      }
      fitAll();
    }

    /* ---------- Game logic ---------- */
    function isSolvedWord(w){ return solvedGroups.some(g => g.words.includes(w)); }
    function buildInitialLayout(p){ const words = p.categories.flatMap(c => c.words); shuffle(words); layout = words; }

    function toggleWord(el, word){
      if (isSolvedWord(word)) return;
      const i = selected.indexOf(word);
      if (i >= 0){ selected.splice(i,1); el.classList.remove('sel'); }
      else{
        if (selected.length === 4){ $$('.tile.sel').forEach(n=>n.classList.remove('sel')); selected=[word]; el.classList.add('sel'); }
        else { selected.push(word); el.classList.add('sel'); }
      }
      updateCheckUI();
    }

    function checkSelection(){
      if (!currentPuzzle || selected.length !== 4) return;
      const pick = new Set(selected);
      const match = currentPuzzle.categories.find(c => c.words.every(w => pick.has(w)));
      if (match && !solvedGroups.some(g => g.title === match.title)){
        // clear staged hint if it was this group
        if (stagedHelp && stagedHelp.group && stagedHelp.group.title === match.title) stagedHelp = null;
        solvedGroups.push(match);
        const gset = new Set(match.words);
        layout = layout.filter(w => !gset.has(w));
        selected = [];
        updateCheckUI();
        renderGrid();
      } else {
        $$('.tile.sel').forEach(n=>n.classList.remove('sel'));
        selected = []; updateCheckUI();
      }
    }

    function handleHelp(){
      if (!currentPuzzle) return;

      // Second press finishes staged group
      if (stagedHelp && stagedHelp.group){ // reveal group
        const g = stagedHelp.group;
        if (!solvedGroups.some(x=>x.title===g.title)){
          solvedGroups.push(g);
          const gset = new Set(g.words);
          layout = layout.filter(w => !gset.has(w));
        }
        stagedHelp = null;
        selected = [];
        updateCheckUI();
        renderGrid();
        return;
      }

      // First press: stage random unsolved group, bring 2 words to front
      const unsolved = currentPuzzle.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
      if (!unsolved.length) return;
      const group = unsolved[Math.floor(Math.random()*unsolved.length)];
      const words = [...group.words];
      for (let i=words.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [words[i],words[j]]=[words[j],words[i]]; }
      const two = words.slice(0,2);

      stagedHelp = { group, hinted:new Set(two) };
      const rest = layout.filter(w => !stagedHelp.hinted.has(w));
      layout = [...two, ...rest];
      renderGrid();
    }

    /* ---------- Apply date ---------- */
    async function applyDate(dateISO){
      currentDate   = dateISO;
      currentPuzzle = await getPuzzle(dateISO);
      selected=[]; solvedGroups=[]; layout=[]; stagedHelp=null;
      buildInitialLayout(currentPuzzle);
      renderGrid();
      updateCheckUI();
    }

    /* ---------- Boot ---------- */
    async function boot(){
      try{
        manifest = await loadEligibleDates();
        if (!manifest.length) throw new Error('No dates in manifest');
        setDates(manifest);
        const def = manifest[0];
        sel.value = def;
        await applyDate(def);
        sel.addEventListener('change', () => applyDate(sel.value));
        btnCheck.addEventListener('click', checkSelection);
        btnHelp.addEventListener('click', handleHelp);
      }catch(e){
        console.error(e);
        grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;color:var(--muted)">Failed to load puzzles.</div>';
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      sel      = $('#puzzle-select');
      grid     = $('#grid');
      btnCheck = $('#btn-check');
      btnHelp  = $('#btn-help');
      boot();
    });
  })();
  </script>

  <style>
    /* --- SVG arc animation for hint overlay --- */
    .hint-overlay .ring{
      /* CSS applies to the <rect class="ring"> inside the SVG we inject */
      animation: hintDash 3.2s ease-in-out infinite;
      /* ensure we inherit stroke/stroke-width set inline */
    }
    @keyframes hintDash{
      0%   { stroke-dasharray: 0 100; }
      70%  { stroke-dasharray: 75 25; }  /* grow to 3/4 perimeter */
      88%  { stroke-dasharray: 100 0; }  /* tail catches up (full ring) */
      100% { stroke-dasharray: 100 0; }  /* pause */
    }
    @media (prefers-reduced-motion: reduce){
      .hint-overlay .ring{ animation: none; }
    }
  </style>
</body>
</html>
