<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Connect</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no">

  <!-- Montserrat font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg:#fafafa; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb; --focus:#0b57d0;
      --tile-font: 14px;     /* default size */
      --tile-font-min: 5px; /* minimum size when auto-fitting */
      --tile-h: 70px;        /* tile height; keep 4 columns across devices */
    }

/* Full-bleed divider under the top bar */
.page-divider {
  border: 0;
  height: 1px;
  background: var(--border);        /* same as tile outline */
  margin: 8px 0 16px;

  /* full width across the viewport, even inside a centered .wrap */
  width: 100vw;
  max-width: 100vw;
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);
}
    
    html, body { height:100%; }
    *, *::before, *::after { -webkit-text-fill-color: currentColor; box-sizing:border-box; }
    body { margin:0; font-family:'Montserrat', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg); }

    .wrap { max-width:1200px; margin:0 auto; padding:16px; }
    h1 { margin:15px 0 30px; fontsize: var(--heading-size); font-weight:700; letter-spacing:.2px; }
    .sub { color:var(--muted); font-size:12px; margin:0 0 12px; }

    /* Toolbar */
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px; }
    select, button {
      border:1px solid var(--border); background:var(--card); border-radius:10px;
      padding:8px 10px; font-size:14px; cursor:pointer; color:var(--fg); -webkit-appearance:none; appearance:none;
    }
    button { font-weight:600; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    a { color: inherit; text-decoration: none; }
    .sr-only { position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

.topbar {
  display: flex;
  align-items: center;          /* vertically center select vs H1 */
  justify-content: space-between;
  gap: 12px;
  padding-bottom: 8px;          /* space above the line */
  margin-bottom: 16px;          /* space below the line */
  position: relative;           /* enable the full-bleed line */
}

/* Full-bleed, 1px light grey line that matches tile borders */
.topbar::after {
  content: "";
  position: absolute;
  left: 50%;
  transform: translateX(-50%);  /* center relative to viewport */
  bottom: -0.5px;               /* crisp line */
  width: 100vw;                 /* full viewport width */
  height: 1px;
  background: var(--border);    /* same colour as tile outlines */
  pointer-events: none;
}

/* Optional: ensure the heading size looks right (uses proper CSS property) */
.topbar .title {
  margin: 10px 0;
  font-size: 28px;              /* tweak to taste */
  font-weight: 700;
  letter-spacing: .2px;
}


/* Optional: tune heading spacing/size */
.topbar .title { 
  margin: 15px 0 30px; 
  font-size: 32px;               /* adjust to taste */
  font-weight: 700; 
  letter-spacing: .2px; 
}

/* Keep the select tidy on one line */
.topbar .date-slot select {
  min-width: 100px;              /* tweak if you want narrower/wider */
  white-space: nowrap;
}

/* On very small screens, keep them on one line if possible; otherwise let it wrap */
@media (max-width: 360px) {
  .topbar .date-slot select { min-width: 160px; }
}


    
    /* Grid & tiles */

.check-wrap {
  display: flex;
  justify-content: center;
  margin-top: 12px;
}

.check-btn {
  border: 1px solid var(--border);
  background: var(--card);
  color: var(--fg);
  border-radius: 10px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
  transition: background .15s ease, color .15s ease, border-color .15s ease, opacity .15s ease;
}

/* turns black with white text when 4 tiles selected */
.check-btn.ready {
  background: #111;
  border-color: #111;
  color: #fff;
}



.actions {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-top: 12px;
}

/* Optional: keep buttons consistent; you likely already have base styles for button */
.actions .help-btn,
.actions .check-btn {
  border: 1px solid var(--border);
  background: var(--card);
  color: var(--fg);
  border-radius: 10px;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
}

/* You already have the “ready” style for Check; keep it */
.check-btn.ready {
  background: #111;
  border-color: #111;
  color: #fff;
}


    
    .grid { display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; max-width:1200px; margin:0 auto; }
    .tile {
      height:var(--tile-h); border:1px solid var(--border); border-radius:14px; background:var(--card);
      font-weight:700; font-size:var(--tile-font); letter-spacing:.2px; padding:0 10px;
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
      transition: background .15s ease, border-color .15s ease, transform .15s ease;
      user-select:none; overflow:hidden; white-space:nowrap; color: var(--fg);
    }
    .tile.solved { opacity:.95; }
    .tile:focus-visible { outline:2px solid var(--focus); outline-offset:2px; }

    .status { margin:14px 0; font-size:14px; color:var(--muted); min-height:1.5em; text-align:center; }
    .footer { text-align:center; color:var(--muted); font-size:12px; margin-top:16px; }
    code { background:#eee; padding:1px 4px; border-radius:4px; }

  

 /* Pastel palette for solved groups */
    .tile.solved.solved-group.p-blue   { background:#e8f2ff !important; border-color:#cfe5ff !important; color:#0f253a !important; }
    .tile.solved.solved-group.p-yellow { background:#fff7cc !important; border-color:#ffe78a !important; color:#3a3200 !important; }
    .tile.solved.solved-group.p-pink   { background:#ffe0ea !important; border-color:#ffc3d6 !important; color:#3a0e20 !important; }
    .tile.solved.solved-group.p-green  { background:#e6f7e6 !important; border-color:#c9ebc9 !important; color:#0f2a0f !important; }


/* Animated pastel flow ring for ANY selected tile */
:root { --sel-ring: 3px; } /* ring thickness; 1px matches your normal border */

.tile { --sel-fill:#fff; } /* inner fill default (white) */

.tile.sel {
  /* Make the gradient live in the border so it fits perfectly (no gaps/clipping) */
  border: var(--sel-ring) solid transparent;
  border-radius: 14px; /* match your .tile radius exactly */
  background:
    /* inner layer: the tile fill (changes on hover) */
    linear-gradient(var(--sel-fill), var(--sel-fill)) padding-box,
    /* outer layer: animated pastel flow ring */
    linear-gradient(90deg,
      #FFE78A 0%,
      #C9EBC9 25%,
      #CFE5FF 50%,
      #FFC3D6 75%,
      #FFE78A 100%
    ) border-box;
  background-size: 100% 100%, 300% 100%;
  background-position: 0 0, 0% 50%;
  animation: selPastelFlow 6s linear infinite;
  will-change: background-position;
  box-shadow: 0 1px 2px rgba(0,0,0,.05); /* keep the subtle shadow */
}



@keyframes selPastelFlow {
  0%   { background-position: 0 0,   0% 50%; }
  100% { background-position: 0 0, 300% 50%; }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  .tile.sel { animation: none; }
}









    
    /* Solved group container spanning full width */
    .solved-group { grid-column:1 / -1; padding:12px; border-radius:14px; text-align:center; display:flex; flex-direction:column; gap:4px; }
    .solved-title { font-weight:700; font-size:14px; letter-spacing:.2px; margin:0; text-align:center; }
    .solved-words-line { font-weight:500; font-size:14px; opacity:.95; }

    /* Compact solved panel chips (optional) */
    .solved-list { display:none; }
    .solved { border:1px solid var(--border); border-radius:12px; padding:8px 10px; font-weight:600; display:flex; flex-wrap:wrap; gap:8px; align-items:center; background:var(--card); }

    /* Keep 4 columns even on small screens; tiles will shrink and auto-fit text */
    @media (max-width: 360px) {
      :root { --tile-font: 13px; --tile-h: 78px; --heading-size: clamp(100px, 6vw, 100px);}
    }



    
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Top bar: title left, date select right -->
<div class="topbar">
  <h1 class="title">connect</h1>
  <div class="date-slot">
    <label for="puzzle-select" class="sr-only">Choose puzzle</label>
    <select id="puzzle-select" aria-label="Choose puzzle"></select>
  </div>
</div>



    <div id="solved" class="solved-list" aria-live="polite"></div>
    <div id="grid" class="grid" role="grid" aria-label="Connections grid of 16 tiles"></div>
    
   <!-- Bottom actions: Help (left) + Check (right) -->
<div class="actions">
  <button id="btn-help" class="help-btn" title="Reveal two tiles">Help</button>
  <button id="btn-check" class="check-btn" title="Check selected tiles" aria-disabled="true">Check</button>
</div>


    <div class="footer">
    </div>
  </div>

  <!-- No embedded JSON. The app fetches /puzzles/manifest.json and /puzzles/<date>.json -->

 
(function () {
  /* ========= Helpers ========= */
  const $  = (sel, root = document) => root.querySelector(sel);
  const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
  const shuffle = arr => { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]] = [arr[j],arr[i]]; } return arr; };
  const PASTELS = ['p-blue','p-yellow','p-pink','p-green'];

  /* ========= Elements ========= */
  const sel        = $('#puzzle-select');
  const grid       = $('#grid');
  const solvedList = $('#solved');
  const btnCheck   = $('#btn-check');
  const btnHelp    = $('#btn-help');
  const msg        = $('#msg');

  /* ========= State ========= */
  let manifest = [];                 // dates newest-first
  const puzzleCache = new Map();     // date -> puzzle
  let currentDate = null;
  let selected = [];
  let solvedGroups = [];
  let layout = [];
  let stagedHelp = null;             // { group, hinted:Set<string>, color }

  /* ========= Fit text ========= */
  const BASE_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font')) || 14;
  const MIN_SIZE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font-min')) || 10;
  function fits(el){ return el.scrollWidth <= el.clientWidth && el.scrollHeight <= el.clientHeight; }
  function fitText(el){
    el.style.fontSize = BASE_SIZE + 'px';
    if (fits(el)) return;
    let size = BASE_SIZE;
    while (size > MIN_SIZE) {
      size -= 1;
      el.style.fontSize = size + 'px';
      if (fits(el)) break;
    }
  }
  function fitAllTiles(){ [...$$('.tile'), ...$$('[data-fit]')].forEach(fitText); }
  const ro = new ResizeObserver(() => fitAllTiles());

  /* ========= UK date gating ========= */
  function todayUK() {
    const parts = new Intl.DateTimeFormat('en-CA', {
      timeZone: 'Europe/London', year:'numeric', month:'2-digit', day:'2-digit'
    }).formatToParts(new Date());
    const y = parts.find(p => p.type === 'year').value;
    const m = parts.find(p => p.type === 'month').value;
    const d = parts.find(p => p.type === 'day').value;
    return `${y}-${m}-${d}`;
  }
  const PREVIEW_MODE = new URLSearchParams(location.search).has('preview');

  async function loadEligibleDates() {
    const res = await fetch('puzzles/manifest.json', { cache: 'no-store' });
    const all = await res.json(); // newest-first
    if (PREVIEW_MODE) return all;
    const cutoff = todayUK();
    const eligible = all.filter(d => d <= cutoff);
    return eligible.length ? eligible : all;
  }

  async function fetchPuzzle(dateISO) {
    if (puzzleCache.has(dateISO)) return puzzleCache.get(dateISO);
    const res = await fetch(`puzzles/${dateISO}.json`, { cache: 'no-store' });
    if (!res.ok) throw new Error(`Could not load puzzle for ${dateISO}`);
    const data = await res.json();
    puzzleCache.set(dateISO, data);
    return data;
  }

  async function populateSelectWithDates(dates) {
    sel.innerHTML = '';
    for (const d of dates) {
      const opt = document.createElement('option');
      opt.value = d;
      opt.textContent = d;
      sel.appendChild(opt);
    }
  }

  /* ========= Single source of truth to display a date ========= */
  async function applyDate(dateISO) {
    const pj = await fetchPuzzle(dateISO);

    // Reset per-puzzle state
    currentDate   = dateISO;
    selected      = [];
    solvedGroups  = [];
    layout        = [];
    stagedHelp    = null;

    // Expose for existing code paths that rely on globals
    window.puzzles      = [pj];
    window.currentIndex = 0;
    window.selected     = selected;
    window.solvedGroups = solvedGroups;
    window.layout       = layout;

    // Render via your existing flow
    if (typeof startPuzzle === 'function') startPuzzle();
  }

  /* ========= Boot: only load newest eligible (≤ today UK) ========= */
  async function bootFromManifest() {
    try {
      manifest = await loadEligibleDates();          // filtered list
      await populateSelectWithDates(manifest);

      const defaultDate = manifest[0];               // newest eligible
      sel.value = defaultDate;

      // Force correct puzzle immediately (prevents “tomorrow” on first paint)
      await applyDate(defaultDate);

      // Keep using the same path on user change
      sel.addEventListener('change', async () => {
        await applyDate(sel.value);
      });
    } catch (e) {
      console.error(e);
      if (msg) msg.textContent = 'Failed to load puzzles.';
    }
  }

  /* ========= Misc UI helpers you already had ========= */
  function wordsOfSolved() { return solvedGroups.flatMap(g => g.words); }
  function isSolvedWord(w) { return solvedGroups.some(g => g.words.includes(w)); }
  function buildInitialLayout(p) {
    const words = p.categories.flatMap(c => c.words);
    shuffle(words);
    layout = words;
  }
  function rebuildLayoutSolvedFirst() {
    const top = []; const seen = new Set();
    for (const g of solvedGroups) for (const w of g.words) if (!seen.has(w)) { top.push(w); seen.add(w); }
    const rest = layout.filter(w => !seen.has(w));
    layout = [...top, ...rest];
  }
  function colorClassForWord(w) {
    for (let i = 0; i < solvedGroups.length; i++) {
      if (solvedGroups[i].words.includes(w)) return PASTELS[i] || PASTELS[PASTELS.length - 1];
    }
    return '';
  }
  function updateCheckUI() {
    const ready = selected.length === 4;
    btnCheck.classList.toggle('ready', ready);
    btnCheck.setAttribute('aria-disabled', ready ? 'false' : 'true');
  }

  /* ========= Start the app (and ONLY this boot) ========= */
  document.addEventListener('DOMContentLoaded', () => {
    // IMPORTANT: do NOT call any old boot like loadEmbedded()/startPuzzle() here.
    bootFromManifest();
  });
})();



    // ===== Render =====
    function renderGrid() {
      grid.innerHTML = '';

      // solved groups (full-width)
      solvedGroups.forEach((g, idx) => {
        const cont = document.createElement('div');
        cont.className = `tile solved solved-group ${PASTELS[idx] || PASTELS[PASTELS.length - 1]}`;
        cont.style.gridColumn = '1 / -1';

        const title = document.createElement('div');
        title.className = 'solved-title';
        title.textContent = g.title;

        const wordsLine = document.createElement('div');
        wordsLine.className = 'solved-words-line';
        wordsLine.textContent = g.words.join(', ');

        cont.appendChild(title);
        cont.appendChild(wordsLine);
        grid.appendChild(cont);
      });

      // remaining tiles
      for (const w of layout) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tile';
        btn.textContent = w;
        // HINT: color the hinted tiles
        if (stagedHelp && stagedHelp.hinted && stagedHelp.hinted.has(w)) {
          btn.classList.add('hint', stagedHelp.color);
          }
        btn.addEventListener('click', () => toggleWord(btn, w));
        grid.appendChild(btn);
        ro.observe(btn);
      }
      fitAllTiles();
    }

    function renderSolvedPanel() {
      solvedList.innerHTML = '';
      solvedGroups.forEach((g, idx) => {
        const div = document.createElement('div');
        div.className = `solved ${PASTELS[idx] || PASTELS[PASTELS.length - 1]}`;
        div.innerHTML = `<span>${g.title}</span><span style="opacity:.6">•</span><span>${g.words.join(', ')}</span>`;
        solvedList.appendChild(div);
      });
    }

    // ===== Game flow =====
    async function startPuzzle() {
      selected = [];
      solvedGroups = [];
      stagedHelp = null;
      updateCheckUI();

      const p = await loadPuzzle(currentDate);
      buildInitialLayout(p);
      renderGrid();
    }

    function toggleWord(el, word) {
  if (isSolvedWord(word)) return;

  const i = selected.indexOf(word);

  if (i >= 0) {
    // Deselect allowed (even for hinted tiles)
    selected.splice(i, 1);
    el.classList.remove('sel');
  } else {
    // Select
    if (selected.length === 4) {
      clearSelectionClasses();
      selected = [word];
      el.classList.add('sel');
    } else {
      selected.push(word);
      el.classList.add('sel');
    }
  }

  if (typeof updateCheckUI === 'function') updateCheckUI();
}


    function clearSelectionClasses() {
      $$('.tile.sel').forEach(n => n.classList.remove('sel'));
    }

    function checkSelection() {
      if (selected.length !== 4) return;
      loadPuzzle(currentDate).then(p => {
        const pick = new Set(selected);
        const match = p.categories.find(c => c.words.every(w => pick.has(w)));

        if (match && !solvedGroups.some(g => g.title === match.title)) {
          revealGroup(match);
        } else {
          clearSelectionClasses();
          selected = [];
          updateCheckUI();

        }
      });
    }

    function revealGroup(group) {
        if (stagedHelp && stagedHelp.group && stagedHelp.group.title === group.title) {
    stagedHelp = null;
  }
      solvedGroups.push(group);
      const gset = new Set(group.words);
      layout = layout.filter(w => !gset.has(w));
      selected = [];
      updateCheckUI();
      renderGrid();
    }

    function helpSolveOne(randomize=true) {
      loadPuzzle(currentDate).then(p => {
        const unsolved = p.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
        if (!unsolved.length) return;
        const group = randomize ? unsolved[Math.floor(Math.random()*unsolved.length)] : unsolved[0];
        revealGroup(group);
      });
    }



    // Wire up controls
    btnCheck.addEventListener('click', checkSelection);
btnHelp.addEventListener('click', handleHelp);

function handleHelp() {
  // Load the current puzzle (for the /puzzles loader)
  loadPuzzle(currentDate).then(p => {
    // If we already staged a hint, finish that group on second press
    if (stagedHelp && stagedHelp.group) {
      // Reveal/solve that whole group now
      revealGroup(stagedHelp.group);
      return;
    }

    // Otherwise, stage a new random unsolved group and hint 2 tiles
    const unsolved = p.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
    if (!unsolved.length) return;

    // Pick a random group
    const group = unsolved[Math.floor(Math.random() * unsolved.length)];

    // Pick 2 of its words at random
    const words = [...group.words];
    for (let i = words.length - 1; i > 0; i--) { // shuffle
      const j = Math.floor(Math.random() * (i + 1));
      [words[i], words[j]] = [words[j], words[i]];
    }
    const two = words.slice(0, 2);

    // Assign it the *next* pastel (same as it will be when solved)
    const color = PASTELS[Math.min(solvedGroups.length, PASTELS.length - 1)] || PASTELS[0];

    // Stage hint state
    stagedHelp = { group, hinted: new Set(two), color };

    // Move the two hinted tiles to the top of the unsolved layout (first row)
    // 1) Remove them from wherever they are
    const rest = layout.filter(w => !stagedHelp.hinted.has(w));
    // 2) Put them at the front
    layout = [...two, ...rest];

    // Re-render to show colored, pinned tiles under solved rows
    renderGrid();
  });
}

    // Boot
    (async function init(){
      await loadManifest();
      if (!manifest.length) return;
      populateSelect();
      currentDate = manifest[0];
      sel.value = currentDate;
      await startPuzzle();
    })();
  })();
  </script>
</body>
</html>





















