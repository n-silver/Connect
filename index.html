
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Connections</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no">

  <!-- Montserrat font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg:#fafafa; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb; --focus:#0b57d0;
      --tile-font: 14px;     /* default size */
      --tile-font-min: 10px; /* minimum size when auto-fitting */
      --tile-h: 84px;        /* tile height; keep 4 columns across devices */
    }

    html, body { height:100%; }
    *, *::before, *::after { -webkit-text-fill-color: currentColor; box-sizing:border-box; }
    body { margin:0; font-family:'Montserrat', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--fg); }

    .wrap { max-width:900px; margin:0 auto; padding:16px; }
    h1 { margin:10px 0 20px; font-size: var(--heading-size); font-weight:700; letter-spacing:.2px; }
    .sub { color:var(--muted); font-size:12px; margin:0 0 12px; }

    /* Toolbar */
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px; }
    select, button {
      border:1px solid var(--border); background:var(--card); border-radius:10px;
      padding:8px 10px; font-size:14px; cursor:pointer; color:var(--fg); -webkit-appearance:none; appearance:none;
    }
    button { font-weight:600; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    a { color: inherit; text-decoration: none; }
    .sr-only { position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    /* Grid & tiles */
    .grid { display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; max-width:680px; margin:0 auto; }
    .tile {
      height:var(--tile-h); border:1px solid var(--border); border-radius:14px; background:var(--card);
      font-weight:700; font-size:var(--tile-font); letter-spacing:.2px; padding:0 10px;
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
      transition: background .15s ease, border-color .15s ease, transform .15s ease;
      user-select:none; overflow:hidden; white-space:nowrap; color: var(--fg);
    }
    .tile:hover { background:#f3f4f6; }
    .tile.sel { background:#efefef; border-color:var(--border); }
    .tile.solved { opacity:.95; }
    .tile:focus-visible { outline:2px solid var(--focus); outline-offset:2px; }

    .status { margin:14px 0; font-size:14px; color:var(--muted); min-height:1.5em; text-align:center; }
    .footer { text-align:center; color:var(--muted); font-size:12px; margin-top:16px; }
    code { background:#eee; padding:1px 4px; border-radius:4px; }

    /* Pastel palette for solved groups */
    .tile.solved.solved-group.p-blue   { background:#e8f2ff !important; border-color:#cfe5ff !important; color:#0f253a !important; }
    .tile.solved.solved-group.p-yellow { background:#fff7cc !important; border-color:#ffe78a !important; color:#3a3200 !important; }
    .tile.solved.solved-group.p-pink   { background:#ffe0ea !important; border-color:#ffc3d6 !important; color:#3a0e20 !important; }
    .tile.solved.solved-group.p-green  { background:#e6f7e6 !important; border-color:#c9ebc9 !important; color:#0f2a0f !important; }

    /* Solved group container spanning full width */
    .solved-group { grid-column:1 / -1; padding:12px; border-radius:14px; text-align:center; display:flex; flex-direction:column; gap:4px; }
    .solved-title { font-weight:700; font-size:14px; letter-spacing:.2px; margin:0; text-align:center; }
    .solved-words-line { font-weight:500; font-size:14px; opacity:.95; }

    /* Compact solved panel chips (optional) */
    .solved-list { display:none; }
    .solved { border:1px solid var(--border); border-radius:12px; padding:8px 10px; font-weight:600; display:flex; flex-wrap:wrap; gap:8px; align-items:center; background:var(--card); }

    /* Keep 4 columns even on small screens; tiles will shrink and auto-fit text */
    @media (max-width: 360px) {
      :root { --tile-font: 13px; --tile-h: 78px; --heading-size: clamp(100px, 6vw, 5px);}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>connect</h1>

    <div class="toolbar">
      <label for="puzzle-select" class="sr-only">Choose puzzle</label>
      <select id="puzzle-select" aria-label="Choose puzzle"></select>
      <button id="btn-reset" title="Reset current puzzle">Reset</button>
      <button id="btn-check" title="Check selected tiles">Check (<span id="sel-count">0</span>/4)</button>
      <button id="btn-help" title="Reveal one random group">Help</button>
      <button id="btn-giveup" title="Reveal all groups">Give Up</button>
      <span id="meta" class="sub" aria-live="polite"></span>
    </div>

    <div id="solved" class="solved-list" aria-live="polite"></div>
    <div id="grid" class="grid" role="grid" aria-label="Connections grid of 16 tiles"></div>
    <div id="msg" class="status" aria-live="polite"></div>

    <div class="footer">
      Loading puzzles from <code>/puzzles</code>.
    </div>
  </div>

  <!-- No embedded JSON. The app fetches /puzzles/manifest.json and /puzzles/<date>.json -->

  <script>
  (function () {
    // ===== Helpers =====
    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
    const shuffle = arr => { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; };

    const PASTELS = ['p-blue','p-yellow','p-pink','p-green'];

    // State
    let manifest = [];            // ['2025-09-13', '2025-09-12', ...] newest first
    let puzzleCache = new Map();  // date -> { date, categories }
    let currentDate = null;
    let selected = [];
    let solvedGroups = [];
    let layout = [];

    // Elements
    const sel = $('#puzzle-select');
    const grid = $('#grid');
    const solvedList = $('#solved');
    const btnReset = $('#btn-reset');
    const btnCheck = $('#btn-check');
    const btnHelp = $('#btn-help');
    const btnGiveUp = $('#btn-giveup');
    const selCount = $('#sel-count');
    const msg = $('#msg');
    const meta = $('#meta');

    // Font-fit helpers
    const BASE_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font')) || 14;
    const MIN_SIZE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font-min')) || 10;
    function fits(el){ return el.scrollWidth <= el.clientWidth && el.scrollHeight <= el.clientHeight; }
    function fitText(el){
      el.style.fontSize = BASE_SIZE + 'px';
      if (fits(el)) return;
      let size = BASE_SIZE;
      while (size > MIN_SIZE) {
        size -= 1;
        el.style.fontSize = size + 'px';
        if (fits(el)) break;
      }
    }
    function fitAllTiles(){ [...$$(".tile"), ...$$("[data-fit]")].forEach(fitText); }
    const ro = new ResizeObserver(() => fitAllTiles());

    // ===== Loading =====
    async function fetchJSON(url){
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
      return await res.json();
    }

    async function loadManifest() {
      try {
        manifest = await fetchJSON('/puzzles/manifest.json');
        if (!Array.isArray(manifest) || !manifest.length) throw new Error('empty manifest');
      } catch {
        // fallback to latest.json only
        try {
          const latest = await fetchJSON('/puzzles/latest.json');
          if (latest?.date) { manifest = [latest.date]; puzzleCache.set(latest.date, latest); }
        } catch (e) {
          console.error('Failed to load any puzzle data', e);
          msg.textContent = 'Could not load puzzle data. Please try again later.';
          manifest = [];
        }
      }
    }

    async function loadPuzzle(date) {
      if (puzzleCache.has(date)) return puzzleCache.get(date);
      try {
        const data = await fetchJSON(`/puzzles/${date}.json`);
        puzzleCache.set(date, data);
        return data;
      } catch {
        // fallback: latest
        const data = await fetchJSON(`/puzzles/latest.json`);
        puzzleCache.set(data.date, data);
        return data;
      }
    }

    function populateSelect() {
      sel.innerHTML = '';
      manifest.forEach((d) => {
        const opt = document.createElement('option');
        opt.value = d;
        opt.textContent = d;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', async () => {
        currentDate = sel.value;
        await startPuzzle(); // reload for selected date
      });
    }

    // ===== Layout helpers =====
    function wordsOfSolved() { return solvedGroups.flatMap(g => g.words); }
    function isSolvedWord(w) { return solvedGroups.some(g => g.words.includes(w)); }

    function buildInitialLayout(p) {
      const words = p.categories.flatMap(c => c.words);
      shuffle(words);
      layout = words;
    }

    function rebuildLayoutSolvedFirst() {
      const top = [];
      const seen = new Set();
      for (const g of solvedGroups) for (const w of g.words) if (!seen.has(w)) { top.push(w); seen.add(w); }
      const rest = layout.filter(w => !seen.has(w));
      layout = [...top, ...rest];
    }

    function colorClassForWord(w) {
      for (let i = 0; i < solvedGroups.length; i++) {
        if (solvedGroups[i].words.includes(w)) return PASTELS[i] || PASTELS[PASTELS.length - 1];
      }
      return '';
    }

    // ===== Render =====
    function renderGrid() {
      grid.innerHTML = '';

      // solved groups (full-width)
      solvedGroups.forEach((g, idx) => {
        const cont = document.createElement('div');
        cont.className = `tile solved solved-group ${PASTELS[idx] || PASTELS[PASTELS.length - 1]}`;
        cont.style.gridColumn = '1 / -1';

        const title = document.createElement('div');
        title.className = 'solved-title';
        title.textContent = g.title;

        const wordsLine = document.createElement('div');
        wordsLine.className = 'solved-words-line';
        wordsLine.textContent = g.words.join(', ');

        cont.appendChild(title);
        cont.appendChild(wordsLine);
        grid.appendChild(cont);
      });

      // remaining tiles
      for (const w of layout) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tile';
        btn.textContent = w;
        btn.addEventListener('click', () => toggleWord(btn, w));

        grid.appendChild(btn);
        ro.observe(btn);
      }
      fitAllTiles();
    }

    function renderSolvedPanel() {
      solvedList.innerHTML = '';
      solvedGroups.forEach((g, idx) => {
        const div = document.createElement('div');
        div.className = `solved ${PASTELS[idx] || PASTELS[PASTELS.length - 1]}`;
        div.innerHTML = `<span>${g.title}</span><span style="opacity:.6">•</span><span>${g.words.join(', ')}</span>`;
        solvedList.appendChild(div);
      });
    }

    // ===== Game flow =====
    async function startPuzzle() {
      selected = [];
      solvedGroups = [];
      selCount.textContent = '0';
      msg.textContent = '';

      const p = await loadPuzzle(currentDate);
      buildInitialLayout(p);
      renderGrid();
      meta.textContent = `Date: ${p.date || '—'}`;
    }

    function toggleWord(el, word) {
      if (isSolvedWord(word)) return;
      const i = selected.indexOf(word);
      if (i >= 0) {
        selected.splice(i,1);
        el.classList.remove('sel');
      } else {
        if (selected.length === 4) {
          clearSelectionClasses();
          selected = [word];
          el.classList.add('sel');
        } else {
          selected.push(word);
          el.classList.add('sel');
        }
      }
      selCount.textContent = String(selected.length);
    }

    function clearSelectionClasses() {
      $$('.tile.sel').forEach(n => n.classList.remove('sel'));
    }

    function checkSelection() {
      if (selected.length !== 4) return;
      loadPuzzle(currentDate).then(p => {
        const pick = new Set(selected);
        const match = p.categories.find(c => c.words.every(w => pick.has(w)));

        if (match && !solvedGroups.some(g => g.title === match.title)) {
          revealGroup(match);
          msg.textContent = `✓ ${match.title}`;
        } else {
          msg.textContent = '✗ Not a group';
          clearSelectionClasses();
          selected = [];
          selCount.textContent = '0';
        }
      });
    }

    function revealGroup(group) {
      solvedGroups.push(group);
      const gset = new Set(group.words);
      layout = layout.filter(w => !gset.has(w));
      selected = [];
      selCount.textContent = '0';
      renderGrid();
      if (solvedGroups.length === 4) msg.textContent = '🎉 Completed!';
    }

    function helpSolveOne(randomize=true) {
      loadPuzzle(currentDate).then(p => {
        const unsolved = p.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
        if (!unsolved.length) return;
        const group = randomize ? unsolved[Math.floor(Math.random()*unsolved.length)] : unsolved[0];
        revealGroup(group);
        msg.textContent = `🪄 Helped: ${group.title}`;
      });
    }

    function giveUpRevealAll() {
      loadPuzzle(currentDate).then(p => {
        const unsolved = p.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
        unsolved.forEach(g => revealGroup(g));
        msg.textContent = 'Revealed all answers.';
      });
    }

    // Wire up controls
    btnCheck.addEventListener('click', checkSelection);
    btnReset.addEventListener('click', startPuzzle);
    btnHelp.addEventListener('click', () => helpSolveOne(true));
    btnGiveUp.addEventListener('click', giveUpRevealAll);

    // Boot
    (async function init(){
      await loadManifest();
      if (!manifest.length) return;
      populateSelect();
      currentDate = manifest[0];
      sel.value = currentDate;
      await startPuzzle();
    })();
  })();
  </script>
</body>
</html>






