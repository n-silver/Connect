<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Connect</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no" />
  <!-- Montserrat font -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      /* Base UI */
      --bg:#fafafa; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb; --focus:#0b57d0;
      --tile-font:14px; --tile-font-min:5px; --tile-h:80px;

      /* Corner radius (master + per-component aliases) */
      --radius:8px;
      --radius-btn:var(--radius);
      --radius-input:var(--radius);
      --radius-tile:var(--radius);
      --radius-solved:var(--radius);

      /* Pastel palette */
      --pastel-blue-bg:#e7f9ff;   --pastel-blue-border:#b8ecff;   --pastel-blue-fg:#0e2433;
      --pastel-yellow-bg:#fff7cc; --pastel-yellow-border:#ffe78a; --pastel-yellow-fg:#3a3200;
      --pastel-pink-bg:#f4e6ff;   --pastel-pink-border:#dac6ff;   --pastel-pink-fg:#291d3a;
      --pastel-green-bg:#e6f7e6;  --pastel-green-border:#c9ebc9;  --pastel-green-fg:#0f2a0f;

      /* Animated selection ring (uses border tones) */
      --ring-yellow: var(--pastel-yellow-border);
      --ring-green:  var(--pastel-green-border);
      --ring-blue:   var(--pastel-blue-border);
      --ring-pink:   var(--pastel-pink-border);

      /* Buttons */
      --btn-ready-bg:#111; --btn-ready-fg:#fff;

      /* Selected ring thickness */
      --sel-ring:3px;
    }

    html,body{height:100%}
    *,*::before,*::after{box-sizing:border-box; -webkit-text-fill-color:currentColor}
    body{margin:0; font-family:'Montserrat',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--fg)}

    .wrap{max-width:1200px; margin:0 auto; padding:12px}

    /* Top bar with full-bleed divider */
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding-bottom:15px; margin-bottom:16px; position:relative;
    }
    .topbar::after{
      content:""; position:absolute; left:50%; transform:translateX(-50%);
      bottom:-0.5px; width:100vw; height:1px; background:var(--border); pointer-events:none;
    }
    .title{ margin:10px 0; font-size:32px; font-weight:700; letter-spacing:.2px; text-transform:lowercase }
    .date-slot select{ min-width:110px; white-space:nowrap }

    /* Inputs and buttons (radius vars applied) */
    button{
      border:1px solid var(--border);
      background:var(--card);
      color:var(--fg);
      border-radius:var(--radius-btn);
      padding:8px 10px;
      font-size:14px;
      font-weight:700;
      cursor:pointer;
      appearance:none;
    }
    button:disabled{ opacity:.5; cursor:not-allowed }

    select{
      border:1px solid var(--border);
      background:var(--card);
      color:var(--fg);
      border-radius:var(--radius-input);
      padding:8px 10px;
      font-size:14px;
      cursor:pointer;
      appearance:none;
    }

    .actions{ display:flex; justify-content:center; align-items:center; gap:8px; margin-top:12px }
    .help-btn, .check-btn{ padding:10px 16px }
/* Gas-like, merging pastel FILL when 4 tiles are selected */
.check-btn.ready{
  border: 1px solid var(--border);           /* keep normal outline */
  border-radius: var(--radius-btn);
  color: #111;                                /* dark text reads well on light pastels */
  background:
    /* Yellow blob */
    radial-gradient(60% 60% at 20% 30%,
      rgba(255,231,138,0.85) 0%,
      rgba(255,231,138,0.40) 45%,
      rgba(255,231,138,0.00) 70%) no-repeat,
    /* Blue blob */
    radial-gradient(55% 55% at 80% 25%,
      rgba(207,229,255,0.85) 0%,
      rgba(207,229,255,0.35) 45%,
      rgba(207,229,255,0.00) 70%) no-repeat,
    /* Green blob */
    radial-gradient(60% 60% at 30% 80%,
      rgba(201,235,201,0.85) 0%,
      rgba(201,235,201,0.40) 45%,
      rgba(201,235,201,0.00) 70%) no-repeat,
    /* Purple/pink blob (adjust to your current purple if needed) */
    radial-gradient(55% 55% at 75% 75%,
      rgba(202,163,255,0.85) 0%,
      rgba(202,163,255,0.35) 45%,
      rgba(202,163,255,0.00) 70%) no-repeat,
    var(--card); /* base */
  background-size:
    220% 220%,
    200% 200%,
    240% 240%,
    220% 220%,
    auto;
  background-position:
    0% 50%,
    100% 50%,
    50% 100%,
    50% 0%,
    0 0;
  animation: checkGasDrift 24s ease-in-out infinite;
  will-change: background-position;
}

@keyframes checkGasDrift{
  0%{
    background-position:   0%  50%, 100%  50%,  50% 100%,  50%   0%, 0 0;
  }
  25%{
    background-position:  35%  80%,  60%  20%,  20%  60%,  80%  40%, 0 0;
  }
  50%{
    background-position: 100%  50%,   0%  50%,  50%   0%,  50% 100%, 0 0;
  }
  75%{
    background-position:  60%  20%,  20%  80%,  85%  40%,  40%  60%, 0 0;
  }
  100%{
    background-position:   0%  50%, 100%  50%,  50% 100%,  50%   0%, 0 0;
  }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  .check-btn.ready{ animation: none; }
}


    /* Grid & tiles */
    .grid{ display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px; max-width:1200px; margin:0 auto }
    .tile{
      height:var(--tile-h); border:1px solid var(--border); border-radius:var(--radius-tile); background:var(--card);
      font-weight:700; font-size:var(--tile-font); letter-spacing:.2px; padding:0 10px;
      display:flex; align-items:center; justify-content:center; white-space:nowrap; overflow:hidden;
      box-shadow:0 1px 2px rgba(0,0,0,.05); transition:background .15s ease,border-color .15s ease,transform .15s ease;
      color:var(--fg); user-select:none;
    }
    .tile:focus-visible{ outline:2px solid var(--focus); outline-offset:2px }
    .tile.solved{ opacity:.95 }

    /* Selected tiles: animated pastel border ring */
    .tile.sel{
      border:var(--sel-ring) solid transparent; border-radius:var(--radius-tile); /* match .tile */
      background:
        linear-gradient(var(--card),var(--card)) padding-box,
        linear-gradient(90deg,
          var(--ring-yellow) 0%,
          var(--ring-green)  25%,
          var(--ring-blue)   50%,
          var(--ring-pink)   75%,
          var(--ring-yellow) 100%
        ) border-box;
      background-size:100% 100%, 300% 100%;
      background-position:0 0, 0% 50%;
      animation:selPastelFlow 6s linear infinite;
      box-shadow:0 1px 2px rgba(0,0,0,.05);
    }
    @keyframes selPastelFlow{ 0%{background-position:0 0,0% 50%} 100%{background-position:0 0,300% 50%} }
    @media (prefers-reduced-motion:reduce){ .tile.sel{ animation:none } }

    /* Solved group (full-width tile) */
    .solved-group{
      grid-column:1 / -1; padding:12px; border-radius:var(--radius-solved);
      text-align:center; display:flex; flex-direction:column; gap:4px
    }
    .solved-title{ font-weight:700; font-size:14px; letter-spacing:.2px; margin:0 }
    .solved-words-line{ font-weight:500; font-size:12px; opacity:.95 }

    /* Pastel palette for solved groups */
    .tile.solved.solved-group.p-blue   { background:var(--pastel-blue-bg)!important;   border-color:var(--pastel-blue-border)!important;   color:var(--pastel-blue-fg)!important }
    .tile.solved.solved-group.p-yellow { background:var(--pastel-yellow-bg)!important; border-color:var(--pastel-yellow-border)!important; color:var(--pastel-yellow-fg)!important }
    .tile.solved.solved-group.p-pink   { background:var(--pastel-pink-bg)!important;   border-color:var(--pastel-pink-border)!important;   color:var(--pastel-pink-fg)!important }
    .tile.solved.solved-group.p-green  { background:var(--pastel-green-bg)!important;  border-color:var(--pastel-green-border)!important;  color:var(--pastel-green-fg)!important }

    .solved-list{ display:none }
    .sr-only{ position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }

    @media (max-width:360px){
      :root{ --tile-font:13px; --tile-h:80px }
      .date-slot select{ min-width:160px }
    }

  /* ---- Force a single radius everywhere ---- */
:root { --radius: 8px; } /* ← tweak this number */

button,
.help-btn,
.check-btn,
select,
.tile,
.tile.sel,
.solved-group {
  border-radius: var(--radius) !important;
}

/* Helps some browsers apply rounding on <select> */
select { -webkit-appearance: none; background-clip: padding-box; overflow: hidden; }


    
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 class="title">connect</h1>
      <div class="date-slot">
        <label for="puzzle-select" class="sr-only">Choose puzzle</label>
        <select id="puzzle-select" aria-label="Choose puzzle"></select>
      </div>
    </div>

    <div id="solved" class="solved-list" aria-live="polite"></div>
    <div id="grid" class="grid" role="grid" aria-label="Connections grid of 16 tiles"></div>

    <div class="actions">
      <button id="btn-help"  class="help-btn"  title="Reveal two tiles">Help</button>
      <button id="btn-check" class="check-btn" title="Check selected tiles" aria-disabled="true">Check</button>
    </div>
  </div>

  <script>
  (function(){
    /* ---------- Tiny DOM helpers ---------- */
    const $  = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
    const shuffle = a => { for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a };
    const PASTELS = ['p-blue','p-yellow','p-pink','p-green'];

    /* ---------- Elements (late-bound) ---------- */
    let sel, grid, solvedList, btnCheck, btnHelp;

    /* ---------- State ---------- */
    let manifest = [];                 // dates (newest-first)
    const cache = new Map();           // date -> puzzle json
    let currentDate = null;
    let currentPuzzle = null;
    let selected = [];
    let solvedGroups = [];
    let layout = [];
    let stagedHelp = null;             // { group, hinted:Set<string> }

    /* ---------- Fit-to-tile text ---------- */
    const BASE_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font')) || 14;
    const MIN_SIZE  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-font-min')) || 10;
    const fits = el => el.scrollWidth <= el.clientWidth && el.scrollHeight <= el.clientHeight;
    function fitText(el){
      el.style.fontSize = BASE_SIZE + 'px';
      if (fits(el)) return;
      let s = BASE_SIZE;
      while (s > MIN_SIZE) { s--; el.style.fontSize = s + 'px'; if (fits(el)) break; }
    }
    function fitAllTiles(){ [...$$('.tile'), ...$$('[data-fit]')].forEach(fitText); }
    const ro = new ResizeObserver(() => fitAllTiles());

    /* ---------- UK date gating ---------- */
    function todayUK(){
      const parts = new Intl.DateTimeFormat('en-CA',{timeZone:'Europe/London',year:'numeric',month:'2-digit',day:'2-digit'}).formatToParts(new Date());
      const y = parts.find(p=>p.type==='year').value, m=parts.find(p=>p.type==='month').value, d=parts.find(p=>p.type==='day').value;
      return `${y}-${m}-${d}`;
    }
    const PREVIEW_MODE = new URLSearchParams(location.search).has('preview');

    async function fetchJSON(candidates){
      const list = Array.isArray(candidates)?candidates:[candidates];
      const errs = [];
      for (const url of list){
        try{
          const res = await fetch(url,{cache:'no-store'});
          if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
          return await res.json();
        }catch(e){ errs.push(`${url}: ${e.message}`); }
      }
      throw new Error(errs.join(' | '));
    }

    async function loadEligibleDates(){
      const all = await fetchJSON(['puzzles/manifest.json','/puzzles/manifest.json']);
      if (PREVIEW_MODE) return all;
      const cutoff = todayUK();
      const eligible = all.filter(d => d <= cutoff);
      return eligible.length ? eligible : all;
    }

    async function getPuzzle(dateISO){
      if (cache.has(dateISO)) return cache.get(dateISO);
      const data = await fetchJSON([`puzzles/${dateISO}.json`, `/puzzles/${dateISO}.json`]);
      cache.set(dateISO, data);
      return data;
    }

    function setDropdownDates(dates){
      sel.innerHTML = '';
      for (const d of dates){
        const opt = document.createElement('option');
        opt.value = d; opt.textContent = d;
        sel.appendChild(opt);
      }
    }

    /* ---------- Rendering ---------- */
    function renderGrid(){
      grid.innerHTML = '';

      // Solved groups (top, full width)
      solvedGroups.forEach((g, idx) => {
        const wrap = document.createElement('div');
        wrap.className = `tile solved solved-group ${PASTELS[idx] || PASTELS[PASTELS.length-1]}`;
        wrap.style.gridColumn = '1 / -1';

        const t = document.createElement('div'); t.className='solved-title';      t.textContent = g.title;
        const w = document.createElement('div'); w.className='solved-words-line'; w.textContent = g.words.join(', ');

        wrap.appendChild(t); wrap.appendChild(w); grid.appendChild(wrap);
      });

      // Remaining tiles
      for (const w of layout){
        const btn = document.createElement('button');
        btn.type = 'button'; btn.className = 'tile'; btn.textContent = w;

        // Hint cosmetic (keeps normal border so selection effect is visible)
        if (stagedHelp && stagedHelp.hinted && stagedHelp.hinted.has(w)) {
          btn.classList.add('hint');
        }

        btn.addEventListener('click', () => toggleWord(btn, w));
        grid.appendChild(btn);
        ro.observe(btn);
      }
      fitAllTiles();
    }

    /* ---------- Game helpers ---------- */
    const wordsOfSolved = () => solvedGroups.flatMap(g => g.words);
    const isSolvedWord  = w => solvedGroups.some(g => g.words.includes(w));

    function buildInitialLayout(p){
      const words = p.categories.flatMap(c => c.words);
      shuffle(words);
      layout = words;
    }
    function rebuildLayoutSolvedFirst(){
      const top=[]; const seen=new Set();
      for (const g of solvedGroups) for (const w of g.words) if (!seen.has(w)){ top.push(w); seen.add(w); }
      const rest = layout.filter(w => !seen.has(w));
      layout = [...top, ...rest];
    }

    function clearSelectionClasses(){ $$('.tile.sel').forEach(n => n.classList.remove('sel')); }
    function updateCheckUI(){
      const ready = selected.length === 4;
      const btnCheck = $('#btn-check');
      if (btnCheck){
        btnCheck.classList.toggle('ready', ready);
        btnCheck.setAttribute('aria-disabled', ready ? 'false' : 'true');
      }
    }

    function toggleWord(el, word){
      if (isSolvedWord(word)) return;
      const i = selected.indexOf(word);
      if (i >= 0){ selected.splice(i,1); el.classList.remove('sel'); }
      else{
        if (selected.length === 4){ clearSelectionClasses(); selected = [word]; el.classList.add('sel'); }
        else { selected.push(word); el.classList.add('sel'); }
      }
      updateCheckUI();
    }

    function checkSelection(){
      if (selected.length !== 4 || !currentPuzzle) return;
      const pick = new Set(selected);
      const match = currentPuzzle.categories.find(c => c.words.every(w => pick.has(w)));
      if (match && !solvedGroups.some(g => g.title === match.title)){
        revealGroup(match);
      } else {
        clearSelectionClasses(); selected = []; updateCheckUI();
      }
    }

    function revealGroup(group){
      if (stagedHelp && stagedHelp.group && stagedHelp.group.title === group.title) stagedHelp = null;
      solvedGroups.push(group);
      const gset = new Set(group.words);
      layout = layout.filter(w => !gset.has(w));
      selected = [];
      updateCheckUI();
      renderGrid();
    }

    function handleHelp(){
      if (!currentPuzzle) return;

      // Second press completes staged group
      if (stagedHelp && stagedHelp.group){ revealGroup(stagedHelp.group); return; }

      // First press: pick random unsolved group, hint 2 words and move them to front
      const unsolved = currentPuzzle.categories.filter(c => !solvedGroups.some(g => g.title === c.title));
      if (!unsolved.length) return;

      const group = unsolved[Math.floor(Math.random()*unsolved.length)];
      const words = [...group.words];
      for (let i=words.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [words[i],words[j]]=[words[j],words[i]]; }
      const two = words.slice(0,2);

      stagedHelp = { group, hinted:new Set(two) };
      const rest = layout.filter(w => !stagedHelp.hinted.has(w));
      layout = [...two, ...rest];
      renderGrid();
    }

    /* ---------- Apply a date (single source of truth) ---------- */
    async function applyDate(dateISO){
      currentDate   = dateISO;
      currentPuzzle = await getPuzzle(dateISO);

      selected = []; solvedGroups = []; layout = []; stagedHelp = null;

      buildInitialLayout(currentPuzzle);
      renderGrid();
      updateCheckUI();
    }

    /* ---------- Boot ---------- */
    async function boot(){
      try{
        manifest = await loadEligibleDates();
        if (!manifest.length) throw new Error('No dates in manifest.');

        setDropdownDates(manifest);

        const defaultDate = manifest[0]; // newest eligible (≤ today UK)
        sel.value = defaultDate;

        await applyDate(defaultDate); // ensure first paint shows the right day

        sel.addEventListener('change', () => applyDate(sel.value));
        btnCheck.addEventListener('click', checkSelection);
        btnHelp.addEventListener('click', handleHelp);
      }catch(e){
        console.error(e);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      sel        = $('#puzzle-select');
      grid       = $('#grid');
      solvedList = $('#solved');
      btnCheck   = $('#btn-check');
      btnHelp    = $('#btn-help');

      if (!sel || !grid){ console.error('Missing #puzzle-select or #grid'); return; }
      boot();
    });
  })();
  </script>
</body>
</html>




























